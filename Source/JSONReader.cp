#include "JSONReader.h"#include <iostream.h>#include <sstream.h>#include <map.h>#include <string.h>// ---------------------------------------------------------------------------//		¥ JSONReader// ---------------------------------------------------------------------------//	Default constructorJSONReader::JSONReader(){	// Init error tracking	readError = new ReadError();	readError->foundError 	= false;	readError->message 		= "";		rootObject = new JSONObject();	}// ---------------------------------------------------------------------------//		¥ ~JSONReader// ---------------------------------------------------------------------------//	DestructorJSONReader::~JSONReader(){	delete readError;	delete rootObject;}// ---------------------------------------------------------------------------//		¥ getRootObject// ---------------------------------------------------------------------------//	JSONObject*JSONReader::getRootObject(){	return rootObject;}// ---------------------------------------------------------------------------//		¥ readStream// ---------------------------------------------------------------------------//	stringJSONReader::readStream(stringstream& inputStream){	// init root object	//	rootObject->empty();		// Init error object	//	readError->foundError 	= false;	readError->message 		= "";	// init reader	//	JSONObject* currentObject = NULL;		string currentKey 			= "";	string currentMatch 			= "";	JSONValue::Type currentType	= JSONValue::DATA_TYPE_STRING;		bool isAwaitingValue 		= false;		int indent					= 0;			// Read	//	string out = "";	while (inputStream.good() && !readError->foundError)    {	    	char c = inputStream.get();    	    	if (inputStream.good()) {	    	switch (c)	      	{	         	case '{':	            	out += "Found TOKEN_OBJECT_BEGIN \n";	            		            	indent++;	            	isAwaitingValue = false;	            	currentMatch 	= "";	            		            	/*	            		If there is no current object, we point to the root	            	*/	            	if (currentObject == NULL) {	            		currentObject = rootObject;	            	}	            	/*	            		If there is a current element name, 	            		set the new object as a value of the current	            	*/	            	else if (currentKey != ""){	            			            		JSONObject* newObject = new JSONObject();	        	            		newObject->setIndent(indent);	            		newObject->setParent(currentObject);	            		            		if (currentObject->isArray()) {	            			currentObject->pushValue(newObject);	            		}	            		else {	            			currentObject->setValue(currentKey, newObject);	            		}	            		            		currentObject = newObject;	            	}	            	/*	            		There is an error	            	*/	            	else {	            		readError->foundError 	= true;	            	}	            		            	break;	         	case '}':	         		out += "Found TOKEN_OBJECT_END \n";	         			         		isAwaitingValue = false;	            	currentMatch 	= "";	         			         		/*	         			Point to the parent object	         			End the reading if there is no parent object	         		*/	         			         		if (indent > 1) {	         			JSONObject* parent = currentObject->getParent();	         			if (parent != NULL) {	         				currentObject = parent;	         			}	         			else {	         				readError->foundError 	= true;	         			}	         				         		}	         		indent--;	         			            	break;	         	case '[':	         		out += "Found TOKEN_ARRAY_BEGIN \n";	         		/*	         			Create a new array and assign it to the current element	         		*/	         		indent++;	         		isAwaitingValue = true;	         		currentMatch 	= "";	         			         		/*	            		If there is no current object, we point to the root	            	*/	            	if (currentObject == NULL) {	            		currentObject = rootObject;	            	}	            	/*	            		If there is a current element name, 	            		set the new object as a value of the current	            	*/	            	else {	            			            		JSONObject* newObject = new JSONObject(true);	            			            		newObject->setIndent(indent);	            		newObject->setParent(currentObject);	            			            		if (currentObject->isArray()) {	            			currentObject->pushValue(newObject);	            		}	            		else {	            			currentObject->setValue(currentKey, newObject);	            		}	            		            		currentObject = newObject;	            	}	            		            	break;	         	case ']':	         		out += "Found TOKEN_ARRAY_END \n";	         			         		isAwaitingValue = false;	         		currentMatch 	= "";	         			         		if (indent > 1) {	         			JSONObject* parent = currentObject->getParent();	         			if (parent != NULL) {	         				currentObject = parent;	         			}	         			else {	         				readError->foundError 	= true;	         			}	         				         		}	         		indent--;	            	break;	         	case ',':	         		out += "Found TOKEN_NEXT_ELEMENT \n";	         		currentMatch = "";					if (currentObject->isArray()) {						isAwaitingValue = true;					}					else {						isAwaitingValue = false;					}	            	break;	         	case ':':	         		out += "Found TOKEN_MEMBER_ASSIGN \n";	         		currentMatch = "";	         		isAwaitingValue = true;	            	break;	         	case '"':	         		inputStream.unget();	         		currentMatch 	= matchString(inputStream, *readError);	         		currentType 	= JSONValue::DATA_TYPE_STRING;	         		out += "Found TOKEN_STRING : \"" + currentMatch + "\"\n";	            	break;	         	case '-':	         	case '0':	         	case '1':	         	case '2':	         	case '3':	         	case '4':	         	case '5':	         	case '6':	         	case '7':	         	case '8':	         	case '9':	         		inputStream.unget();	         		currentMatch 	= matchNumber(inputStream, *readError);	         		currentType 	= JSONValue::DATA_TYPE_NUMBER;	         			         		out += "Found TOKEN_NUMBER : " + currentMatch + "\n";	            	break;	         	case 't':	         		inputStream.unget();	         		currentMatch 	= matchExpectedString(inputStream, "true", *readError);	         		currentType 	= JSONValue::DATA_TYPE_BOOLEAN;	         			         		out += "Found TOKEN_BOOLEAN : " + currentMatch + "\n";	            	break;	         	case 'f':	         		inputStream.unget();	         		currentMatch 	= matchExpectedString(inputStream, "false", *readError);	         		currentType 	= JSONValue::DATA_TYPE_BOOLEAN;	         			         		out += "Found TOKEN_BOOLEAN : " + currentMatch + "\n";	            	break;	         	case 'n':	         		inputStream.unget();	         		currentMatch 	= matchExpectedString(inputStream, "null", *readError);	         		currentType 	= JSONValue::DATA_TYPE_NULL;	         			         		out += "Found TOKEN_NULL : " + currentMatch + "\n";	            	break;	         	default:	         	{	            	out += "default match \n";	        	}	      	}	      		      	if (currentMatch != ""  && !readError->foundError) {	         			         	// The string is a value	         	//	         	if (isAwaitingValue) {	         			         		// We are in an array	         		if (currentObject->isArray()) {	         			currentObject->pushValue(currentMatch, currentType);	         		}	         		// We are in an object and we have a key	         		else if (currentKey != "") {	            		currentObject->setValue(currentKey, currentMatch, currentType);	         				         		}	         		// We found an error	         		else {	         			readError->foundError 	= true;	         		}	         	}	         		         	// The string is a key	         	else {	         		currentKey = currentMatch;				}	        }   		}    }        if (readError->foundError)    {    	out += "\n\ error parsing JSON: "+readError->message;    }    return out;}// ---------------------------------------------------------------------------//		¥ matchNumber// ---------------------------------------------------------------------------//	stringJSONReader::matchNumber(	stringstream& inputStream,	ReadError& error){	string sNumber = "";   	   	while (inputStream.good() && isValidNumberChar(inputStream.peek()))   	{   		char c = inputStream.get();      	sNumber += c;      	   	}		// check end of token	char nextChar = inputStream.peek();   	if (nextChar != '}' && nextChar != ',' && nextChar != ']')   	{   		error.foundError = true;      	error.message = "Unexpected character after " + sNumber;   	}   	   	return sNumber;}// ---------------------------------------------------------------------------//		¥ matchString// ---------------------------------------------------------------------------//	stringJSONReader::matchExpectedString(	stringstream& inputStream,	const string& expected,	ReadError& error){		string sFound = "";	for(string::size_type i = 0; i < expected.size(); ++i) {			// We start on the second character		char c1 = inputStream.get();		char c2 = expected[i];				sFound += c1;                        	if (!inputStream.good() ||	// did we reach the end before finding what we're looking for...   			c1 != c2) 				// ...or did we find something different?      	{      		error.foundError = true;      		error.message = "Expected " + expected + " but found " + sFound;      	}   	}   	return expected;}// ---------------------------------------------------------------------------//		¥ matchString// ---------------------------------------------------------------------------//	stringJSONReader::matchString(	stringstream& inputStream,	ReadError& error){		// ignore first character '"'	inputStream.get();		string str = "";   	while (inputStream.good() &&          inputStream.peek() != '"')   	{      	char c = inputStream.get();      	// escape?      	if (c == '\\' && inputStream.good()) // shouldn't have reached the end yet      	{         	c = inputStream.get();         	switch (c) {            	case '/':      str += '/';     break;            	case '"':      str += '"';     break;            	case '\\':     str += '\\';    break;            	case 'b':      str += '\b';    break;            	case 'f':      str += '\f';    break;            	case 'n':      str += '\n';    break;            	case 'r':      str += '\r';    break;            	case 't':      str += '\t';    break;            	case 'u':      str += '\u';    break; // TODO: what do we do with this?            	default: {            		error.foundError = true;      				error.message = "Unrecognized escape sequence found in string: \\" + c;            	}         	}      	}      	else {         	str += c;      	}   	}   	// eat the last '"' that we just peeked and check end of token   	char nextChar = inputStream.get();   	if (nextChar != '"')   	{   		error.foundError = true;      	error.message = "unexpected end of file";   		return nil;   	}   	   	return str;}// ---------------------------------------------------------------------------//		¥ isValidNumberChar// ---------------------------------------------------------------------------//	boolJSONReader::isValidNumberChar(char c){	char seqence[] = "0123456789.eE-+";		bool foundInSequence = false;		for (int i=0; i<15; i++)	{		if (seqence[i] == c)		{			foundInSequence = true;		}	}	return foundInSequence;}